\section{Method}\label{method}

\iffalse
the overall approach and rationale.
Why the project was tackled in the chosen way, and why other ways were ruled out.
\fi

\subsection{Methodology}

Given the exploratory nature of this project I elected to take an incremental and iterative approach, developing small parts of the system at any time (increments), and iterating over those parts with improvements as necessity dicated and time allowed. This approach is based on that laid out by Cockburn (2008 \cite{Cockburn08}).

\subsubsection{Phases}

The main phases of development would be:

\begin{enumerate}
    \item Clean up and migrate data
    \item Create initial API app
    \item Connect API with database
    \item Implement routes for API access to wines and authors
    \item Augment API routes for wines and authors with recommendations
    \item Iterate on recommendation methods, evaluating and improving quality
\end{enumerate}

My reason for taking this approach, rather than following a formal development methodology such as the waterfall model, was that my aims and objectives were unbounded, it the sense that there would not be a point at which my system was complete, only a point at which it was minimally complete, followed by a succession of points at which is was improved.

\subsubsection{Minimum Viable Product}

It was clear that I would be doing a large amount of experimental programming, and given my lack of prior experience in the problem domain I felt it inappropriate to attempt to quantify my expectations for the system in terms of detailed requirements. Nevertheless there were very clear minimum objectives for the system, without which it would not be possible to claim any degree of success.

The system should at least:

\begin{itemize}
    \item Provide an HTTP API for accessing wine and user information from the Decanter.com tastings database.
    \item Augment the API results for wines and authors with appropriate recommendations of other similar or interesting wines and author.
    \item Provide API results suitable for machine interpretation by web or mobile applications.
    \item Provide a mechanism by which to evaluate recommendation quality.
\end{itemize}

These requirements in the least should be fulfilled by the system. With this having been done the focus of the project will be on maximising the quality of recommendations.

\subsection{Technologies and Tools}

\subsubsection{Python}

As the main progamming language for my project I chose to use Python. There were several candidate languages, not least Java, but I decided on Python because it has a number of attributes which lent themselves particularly to this project:

\begin{itemize}
    \item Extensive mathematical and scientific libraries, such as numpy \cite{Numpy} and scipy \cite{Scipy}.
    \item Extensive detailed documentation \cite{PythonDocs}.
    \item Widely used in web development, such as by Google and YouTube \cite{PythonQuotes}.
    \item Interactive interpreter, allowing command line interaction and supporting scripting on Unix-like systems \cite{PythonInterpreter}.
\end{itemize}

One deciding factor was that my first enquiry into recommender systems was reading Segaran's code examples in Chapter 2 of Collective Intelligence (2007, Ch.2 \cite{Segaran07}), where the language he uses for his code examples is Python. 

In addition to its suitability for tasks around recommender systems, Python has a solid heritage of web application frameworks, such as Django \cite{DjangoProject} and Flask \cite{Flask}. Django is a fully featured website building framework, and as such carries many features unnecessary for my project, whereas Flask, a ``micro-framework'' \cite{Flask}, appeared to be more lightweight and simple to implement. Therefore I chose to implement my API using Flask \cite{Flask}.

For the most part I considered that my system would suit the stateless, non-persistent nature of a Python web application. The only concern in this regard would be that I would need to recreate objects in memory from scratch with each request rather than persist them as I might using another language, such as using Java with the JPA\cite{JavaJPA}. It was reasonable to suppose that in generating recommendations I would potentially be creating large objects in memory, and that there may be a performance deficit incurred by having to rebuild such object on a per request basis. I resolved that should the lack of persistence prove problematic down the line I would be able to use a persistence mechanism such as Memcached \cite{PythonMemcached} to serve this purpose, and found that there is wide support for such a solution using Python and Flask \cite{FlaskMemcached}.

\subsubsection{MySQL}

Originally I had envisaged a system backed by a PostgreSQL \cite{PostgreSQL} RDBMS, but having received the Decanter.com data as a MySQL \cite{MySQL} database it did not seem, comparing the two systems, that there would be any significant benefit migrating the data to PostgreSQL. Both are widely used in production, and have similar feature sets. For a short time I considered using a NoSQL database such as MongoDB \cite{MongoDB} for my project, but decided against such a solution, recognising that such document-oriented systems are not ideal when joining between tables in the way that I would need to for my wines and tasting notes. It seemed that an RDBMS was ideally suited to the purpose, and there was no reason why that shouldn't be MySQL.

\subsubsection{GitHub}

Given the iterative nature of my development process I envisaged a need to be able to easily version my source code, possibly running several different versions at once, with the ability to revert changes back to any previous state. I also wanted a remote backup of my system in case of problems with my own development computer. In order to do be able to do these things I chose to store my code as a project in GitHub \cite{GitHub}, which is a web service providing Git version control. I chose to use GitHub for my notes and project files also, so that my entire project was stored, versioned and backed up together.

